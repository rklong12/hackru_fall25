# tts.py
"""
Utilities for generating (and persisting) ElevenLabs voice IDs for your characters.

Highlights:
- Voice Design text meets min length (>=100 chars).
- Tries BOTH endpoints for Voice Design:
    /v1/text-to-voice/create-previews   (may return id via header or JSON)
    /v1/text-to-voice/design            (JSON previews)
- Create-voice payload uses voice_name / voice_description (and also name/description for compatibility).
- Fallback to an existing voice is opt-in (allow_fallback=False).
"""

import os
import json
from typing import Dict, List, Optional, Union
import requests
from dotenv import load_dotenv

# --------------------------- Config ---------------------------

load_dotenv()
ELEVEN_API_KEY = os.getenv("ELEVEN_API_KEY")
BASE = "https://api.elevenlabs.io/v1"


class ElevenError(RuntimeError):
    pass


def _headers(json_content: bool = True) -> Dict[str, str]:
    if not ELEVEN_API_KEY:
        raise ElevenError("Missing ELEVEN_API_KEY. Set it in your .env.")
    h = {"xi-api-key": ELEVEN_API_KEY, "accept": "application/json"}
    if json_content:
        h["content-type"] = "application/json"
    return h


# ---------------------- ElevenLabs helpers --------------------

def _build_design_text(name: str, personality: str, background: str) -> str:
    persona = " ".join([s for s in (personality.strip(), background.strip()) if s]).strip()
    if not persona:
        persona = "Warm storyteller with steady pace and clear articulation."
    base = (
        f"My name is {name}. I speak as a {persona.lower()}. "
        f"I greet travelers, weigh my words, and keep my tone true to the moment, "
        f"letting breaths and subtle emphasis color what I say."
    )
    while len(base) < 120:
        base += " I choose words carefully and keep a measured rhythm."
    if len(base) > 240:
        base = base[:240].rstrip() + "."
    return base


def _design_voice_from_prompt(prompt: str, design_text: str) -> str:
    payload = {"text": design_text, "voice_description": prompt}

    # Try create-previews first
    url1 = f"{BASE}/text-to-voice/create-previews"
    r1 = requests.post(url1, headers=_headers(), json=payload, timeout=60)

    if r1.status_code == 200:
        gen_id = r1.headers.get("generated_voice_id")
        if gen_id:
            return gen_id
        try:
            data1 = r1.json()
            previews1 = data1.get("previews", [])
            if previews1 and "generated_voice_id" in previews1[0]:
                return previews1[0]["generated_voice_id"]
        except ValueError:
            pass

    # Fallback legacy endpoint
    url2 = f"{BASE}/text-to-voice/design"
    r2 = requests.post(url2, headers=_headers(), json=payload, timeout=60)
    if r2.status_code == 200:
        data2 = r2.json()
        previews2 = data2.get("previews", [])
        if previews2 and "generated_voice_id" in previews2[0]:
            return previews2[0]["generated_voice_id"]

    r1_text = getattr(r1, "text", "")
    r2_text = getattr(r2, "text", "")
    raise ElevenError(
        "Voice design failed. "
        f"create-previews: {r1.status_code} {r1_text[:200]} | "
        f"design: {r2.status_code} {r2_text[:200]}"
    )


def _create_voice_from_generated(generated_voice_id: str, name: str, description: str) -> str:
    """
    Finalizes a designed voice and returns a reusable voice_id.

    Some deployments expect 'voice_name'/'voice_description' (422 otherwise).
    We send both those AND 'name'/'description' for compatibility.
    """
    url = f"{BASE}/text-to-voice"
    payload = {
        "generated_voice_id": generated_voice_id,
        # Newer/strict keys:
        "voice_name": (name or "RPG Character")[:50],
        "voice_description": (description or "Generated by Voice Design")[:200],
        # Back-compat keys (harmless if ignored):
        "name": (name or "RPG Character")[:50],
        "description": (description or "Generated by Voice Design")[:200],
    }
    r = requests.post(url, headers=_headers(), json=payload, timeout=60)
    if r.status_code >= 400:
        raise ElevenError(f"Create voice failed: {r.status_code} {r.text}")
    data = r.json()
    voice_id = data.get("voice_id") or data.get("id")
    if not voice_id:
        raise ElevenError("Create voice response missing voice_id.")
    return voice_id


def _fallback_pick_existing_voice_id() -> Optional[str]:
    url = f"{BASE}/voices"
    r = requests.get(url, headers=_headers(json_content=False), timeout=30)
    if r.status_code >= 400:
        return None
    data = r.json()
    voices = data.get("voices", [])
    return voices[0].get("voice_id") if voices else None


def _list_voice_ids() -> List[str]:
    url = f"{BASE}/voices"
    r = requests.get(url, headers=_headers(json_content=False), timeout=30)
    r.raise_for_status()
    return [v.get("voice_id") for v in r.json().get("voices", [])]


# ---------------------- File & character IO -------------------

def _load_characters(path: str) -> List[Dict]:
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def _save_characters(path: str, characters: List[Dict]) -> None:
    with open(path, "w", encoding="utf-8") as f:
        json.dump(characters, f, ensure_ascii=False, indent=2)


def _find_character(characters: List[Dict], target: Union[str, int]) -> Dict:
    if isinstance(target, int):
        if target < 0 or target >= len(characters):
            raise IndexError(f"Character index out of range: {target}")
        return characters[target]
    for ch in characters:
        if ch.get("name") == target:
            return ch
    raise ValueError(f"Character named '{target}' not found in characters.json")


# ----------------------- Public entrypoint --------------------

def ensure_voice_id_for_character_in_file(
    target: Union[str, int],
    characters_path: str = "characters.json",
    allow_fallback: bool = False,
) -> str:
    """
    Ensures the specified character has a 'voiceId' persisted in characters.json.

    - If present already, return it.
    - Else: Voice Design (long text) -> generated_voice_id -> create voice -> voice_id.
    - Fallback (optional): pick an existing library voice if generation fails.
    """
    characters = _load_characters(characters_path)
    character = _find_character(characters, target)

    if character.get("voiceId"):
        return character["voiceId"]

    name = character.get("name") or "Unnamed Character"
    personality = (character.get("personality") or "").strip()
    background = (character.get("background") or "").strip()

    traits = "; ".join([t for t in (personality, background) if t]) or "warm storyteller"
    prompt = f"Medieval fantasy NPC voice for '{name}'. Traits: {traits}."
    design_text = _build_design_text(name, personality, background)

    try:
        generated_id = _design_voice_from_prompt(prompt, design_text)
        voice_id = _create_voice_from_generated(
            generated_voice_id=generated_id,
            name=name,
            description=f"Auto-generated for {name}: {personality}"[:200],
        )
        source = "designed-new"
    except Exception as e:
        if not allow_fallback:
            raise
        voice_id = _fallback_pick_existing_voice_id()
        if not voice_id:
            raise ElevenError(f"Failed to generate and no fallback voice available: {e}") from e
        source = "fallback-existing"

    character["voiceId"] = voice_id
    _save_characters(characters_path, characters)
    print(f"[tts] voiceId for '{name}': {voice_id} ({source}, design_text_len={len(design_text)})")
    return voice_id
